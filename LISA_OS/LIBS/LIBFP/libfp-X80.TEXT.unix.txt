{ Copyright 1983, Apple Computer Inc. }


(* File L:X80, Version 21 December 1982. *)

function getbite ( b : bite ) : byt  ;
begin
if b >= 0 then getbite := b else getbite := b + 256 ;
end   ;

function setbite ( b : byt ) : bite   ;
begin
if b < 128 then setbite := b else setbite := b - 256 ;
end   ;

procedure fpswap ; (* Exchanges contents of f[0] and f[1] *)
var
t : fp_register ;
begin
with fpcb_.block do
        begin
        t := f[0] ;
        f[0] := f[1] ;
        f[1] := t ;
        end ;
end   ;

procedure movefp ;
begin
fpcb_.block.f[0] := x ;
end ;

procedure movefp1 ;
begin
fpcb_.block.f[1] := x ;
end ;

procedure fpmove ;
begin
z := fpcb_.block.f[0] ;
end ;

procedure fp1move ;
begin
z := fpcb_.block.f[1] ;
end ;

procedure infinity ;
        (* Sets z to INF.  *)
var i : integer ;
begin
z[0] := 63 ; z[1] := -1 ; 
for i := 2 to 9 do z[i] := 0 ;
end   ;

function fpminus ;
begin
fpminus := (fpcb_.block.f[0].sign) < 0 ;
end   ;

function fpkind ;
begin
case fpcb_.block.f[0].tag of
tagnormal : fpkind := NORML ; (* Normalized *)
tagzero : fpkind := zero ; (* Normal zero *)
taginf : fpkind := inf ; (* Infinity *)
tagnan : fpkind := nan ; (* NAN *)
TagNonNormal : fpkind := NonNormal ; (* Unnormalized or denormalized *)
end   ;
end   ;

function fpminusx ;
begin
fpminusx := x[0] < 0 ;
end   ;

function fpkindx ;
var
leadbyte : integer ;
zerosig : boolean ;
i : integer ;

begin (* fpkindx *)
leadbyte := getbite(x[0]) mod 128 ; (* First byte of abs(x).  *)
if (leadbyte = 64) and (x[1] = 0) then
        begin (* Minimal exponent *)
        zerosig := x[2] = 0  ;
        for i := 3 to 9 do zerosig := zerosig and (x[i] = 0) ;
        if zerosig then fpkindx := zero else fpkindx := NonNormal ;
        end   (* Minimal exponent *)
else if (leadbyte = 63) and (x[1] = -1) then
        begin (* Maximal exponent *)
        zerosig := (getbite(x[2]) mod 128) = 0 ;
                (* I bit doesn't affect INF/NAN determination.  *)
        for i := 3 to 9 do zerosig := zerosig and (x[i] = 0) ;
        if zerosig then fpkindx := inf else fpkindx := nan ;
        end   (* Maximal exponent *)
else if x[2] < 0 then fpkindx := normal else fpkindx := NonNormal ;
end   (* fpkindx *) ;

procedure copysign ;
        (* z gets y with sign of x.  *)
var
xsign, ysign : boolean ;

begin
xsign := x[0] < 0 ; ysign := y[0] < 0 ;
z := y ;
if xsign < ysign then z[0] := z[0] + 128 (* Make z positive like x.  *)
else if ysign < xsign then z[0] := z[0] - 128 ; (* Make z negative like x.  *)
end   ;

function getexponent ( var x : fp_extended ) : integer ;
        (* Returns exponent field of x without judgments about validity. *)
var 

e : integer ;
r : record case boolean of
        false : (rx : fp_extended) ;
        true  : (re : integer) ;
        end ;

begin (* getexponent *)
r.rx := x ;
e := r.re ;
if e < 0 then e := e + $8000 ; (* Remove sign bit of x. *)
if e >= $4000 then e := e + $8000 ; (* Extend sign bit of exponent field. *)
getexponent := e ;
end   (* getexponent *) ;

procedure blockprelude (* var fpb : fp_blocktype *) ;
        (* Save floating point status in fpb, then clears exceptions and traps. *)
begin (* blockprelude *)
fpb := fpcb_.block ;
clrexcepset ;
clrtrapset ;
end   (* blockprelude *) ;

procedure blockpostlude (* var fpb : fp_blocktype ; var trapcoming : boolean *) ;
        (* Restores floating point status from fpb, puts new exceptions in texcep
        and ORs them into excep, and sets trapcoming if a floating
        point trap should occur. *)
var
es, ts, newes, oldes : excepset ;
begin (* blockpostlude *)
getexcepset( newes ) ; (* Newes gets exceptions generated by composite operation. *)
fpcb_.block := fpb ; (* Restore previous status. *)
settexcepset( newes ) ; (* Save new exceptions in texcep. *)
getexcepset( oldes ) ; (* Get old exceptions. *)
es := oldes + newes ; (* OR them together. *)
setexcepset( es ) ; (* Put them all in excep. *)
gettrapset( ts ) ;  (* Get trap flags. *)
trapcoming := (ts * es) <> [] ;
end   (* blockpostlude *) ;

procedure createnan ;
        (* Creates a NaN in z with defined fields.  *)
var ext : fp_6bit ;
begin (* createnan *)
infinity(z) ;
if trap then ext := extension + 64 else ext := extension ;
if (ext=0) and (error=0) and (index=0) then error := nanzero ;
z[2] := setbite(ext) ;
z[3] := setbite(error) ;
z[4] := setbite(index) ;
end   (* createnan *) ;

procedure errornan ;
        (* Creates a NaN in z with defined error code and sets INVOP.  *)
var
err : byt ;
begin (* errornan *)
if error=0 then err := nanzero else err := error ; (* Avoid BG error. *)
createnan(false, 0, err, 0, z) ;
setxcpn(invop,true) ;
end   (* errornan *) ;

procedure checknan (* x : extended ; var z : extended *) ;
        (* z := x but if x is a trapping nan, the trapping bit of z is
        turned off and the Invalid flag is set.  *)
begin (* checknan *)
z := x ;
if ( getbite(z[2]) div 64 ) > 0 then
        begin (* x is a trapping nan *)
        z[2] := setbite(getbite(z[2])-64) ;
        setxcpn(invop, true ) ;
        if fpkindx(z) = inf then errornan( nanzero, z) ;
                (* Look out for converting trapping Nan to Inf *)
        end   (* x is a trapping nan *) ;
end   (* checknan *) ;

procedure nan_parts ;
        (* Divides x up into its pieces. *)
var
z2 : byt ;
i : 7..9 ;
addr : longint ;

begin (* nan_parts *)
z2 := getbite(x[2]) ;
trap := z2 >= 64 ;
extension := z2 mod 64 ;
error := getbite(x[3]) ;
index := getbite(x[4]) ;
index2 := getbite(x[5]) ;
addr := getbite(x[6]) ;
for i := 7 to 9 do addr := 256 * addr + getbite(x[i]) ;
lowpart := pointer(addr) ;
end   (* nan_parts *) ;

procedure choosenan (* x, y : extended ; var z : extended *) ;
        (* x or y must be a nan.  z is set to whichever has the greater
        significand.  z is non trapping.  If either x or y is trapping,
        the Invalid flag is set.  *)
var 
i : integer ;
xb, yb : boolean ;
xex, yex : fp_6bit ;
xer, yer : byt ; xin, yin, xin2, yin2 : byt ;
xlow, ylow : fp_procaddress  ;

procedure dox ; 
begin 
checknan(x,z) ; end ;

procedure doy ; 
begin 
checknan(y,z) ; end ;

begin (* choosenan *)
if fpkindx(x) = nan then
        begin (* x a nan *)
        if fpkindx(y) = nan then
                begin (* both nan *)
                dox ; doy ; (* Check both for trapping *)
                nan_parts( x, xb, xex, xer, xin, xin2, xlow ) ;
                nan_parts( y, yb, yex, yer, yin, yin2, ylow ) ;
                if yer > xer then doy else
                if xer > yer then dox else
                        begin (* Compare significands *)
                        i := 3 ;
                        while (i<7) and (x[i] = y[i]) do i := i + 1 ;
                        if x[i] <> y[i] then 
                                begin (* Different significands *)
                                if getbite(x[i]) < getbite(y[i]) then doy
                                        else dox ;
                                end   (* Different significands *) ;
                        end   (* Compare significands *)
                end   (* both nan *)
                else
                begin (* only x a nan *)
                dox 
                end   (* only x a nan *)
        end   (* x a nan *)
        else
        begin (* only y a nan *)
        doy
        end   (* only y a nan *) ;
end   (* choosenan *) ;

ÿ