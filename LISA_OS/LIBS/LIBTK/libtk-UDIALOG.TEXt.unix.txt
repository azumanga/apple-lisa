(*        >>>>>>>>  U D I A L O G  <<<<<<<<

*)

{$SETC forOS := TRUE}

UNIT UDialog;  {Copyright 1984 by Apple Computer, Inc}

{04/25/84 0015  Added field TEditLegendSelection.tripleClick, and methods TEditLegendSelection.
                     MousePress, MouseMove, and MouseRelease}
{04/23/84 1210  Removed all references to 'underEdit' field of TDialogImage}

{$Setc IsIntrinsic := TRUE }

{$IFC IsIntrinsic}
INTRINSIC;
{$ENDC}


INTERFACE

USES
  {$U libtk/UObject}          UObject,
{$IFC LibraryVersion <= 20}
  {$U UFont}            UFont,
{$ENDC}
  {$U QuickDraw}        QuickDraw,
  {$U libtk/UDraw}            UDraw,

  {$U libtk/UABC}             UABC,
  {$U libtk/UUnivText}        UTKUniversalText,
  {$U libtk/UText}            UText;


CONST
    UDialogVersion  = 'UDialog 25Apr84 16:30';

(*
                          -----  Dialog Building Block for the ToolKit ------



 The Dialog Building Block provides the following standard kinds of dialog Images:

       Button           A Lisa-style button (a round-cornered Rectangle for pushing, with text inside it)
       Checkbox         A checkbox (a box for checking, plus an optional associated textual label)
       Cluster          A set of related checkboxes of which only one is selected at a time
       InputFrame       A place for keyboard input to be inhaled
       Legend           A character string, together with font & face information

       TextDialogImage  A box of text managed by the Text editor  (largely untested)
       PicObject        A QuickDraw picture  (never tested; probably not bankable; status uncertain)

 The basic bankable dialog entity which can be stashed into/retrieved from a Resource File
 is the class TDialog.  For each different kind of dialog box you want, you will typically define
 another subclass of TDialog.

 To EDIT a dialog interactively, you must:
      (1)  Have the menu items '«Edit Dialog' and 'Stop Editing Dialog' in your phrase-file
      (2)  If the dialog is viewed in your main window rather than in a dialog box, (such as Preferences)
             then your own main Window.CanDoCmd should enable uEditDialog whenever the dialog to be editted
             is unambiguously selected in the window and there is not a dialog box up; in this
             case, the dialog editting takes place in a dialog box whereas the dialog itself resides
             in the main window.

      CAUTION: Until Resource Files are incoporated, the edits to a dialog are local to the document
               in which you made the edits, as well as documents made from a stationery pad made from
               that document.

   How to have your own view be a subclass of TDialogView, and still do all of its normal View things,
   while having the Dialog Building Block handle everything that occurs which is relevant to
   its dialogs:

    (a) To draw the non-dialog parts of the view, implement method TDialogView.XDraw
    (b) To set the cursor in the non-dialog parts of the view, implement method TDialogView.XCursorAt
    (c) Implement XMousePress, XMouseMove, and XMouseRelease instead of their non-x counterparts

*)

TYPE

S4 = STRING[4];

TId = STRING[IDLength];

TButtonMetrics =
    RECORD
        height:         INTEGER;
        curvH:          INTEGER;
        curvV:          INTEGER;

        typeStyle:      TTypeStyle;

        expandNum:      INTEGER;   {a button's min width is its text's with times this numerator}
        expandDen:      INTEGER;   {   ... divided by this denominator}

        absMinWidth:    INTEGER;
        penState:       PenState;  {for drawing the round-rect}
    END;

TStringKey =    RECORD         {Keys for Dialogs in Resource Files}
                    trueKey:    LONGINT;
                    key:        S4;
                END;



{-------------------------------------------------------------------------------------------------------}

                                    { ********* CLASSES ********* }

{ -------------------------------- classes implemented in file UDialog2 ------------------------------- }


TDialogWindow = SUBCLASS of TDialogBox  {which itself is in UABC}

    controlPanel:   TPanel;       {One with a dialogView in it; may be told to push its dflt button}
    dialogView:     TDialogView;  {the view installed in SELF.controlPanel}
    mainDialog:     TDialog;      {the first dialog installed in SELF.dialogView}

   {Creation/Destruction}
     FUNCTION TDialogWindow.CREATE(object: TObject; heap: THeap; itsResizability: BOOLEAN;
        itsHeight: INTEGER; itsKeyResponse, itsMenuResponse, itsDownInMainWindowResponse: TDiResponse): TDialogWindow;

   {Showing and Hiding}
    PROCEDURE TDialogWindow.Appear;  OVERRIDE;
    PROCEDURE TDialogWindow.BeDismissed; OVERRIDE;
    FUNCTION  TDialogWindow.CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN;  OVERRIDE;
    PROCEDURE TDialogWindow.Disappear; OVERRIDE;

   {Commands}
    FUNCTION  TDialogWindow.NewCommand(cmdNumber: TCmdNumber): TCommand; OVERRIDE;

  END;  {TDialogWindow interface}


{-------------------------------------------------------------------------------------------------------}


TDialogView = SUBCLASS OF TView  {a view which contains dialog images as well as, possibly, other things}

    rootDialog:         TDialog;    {The children of this object are the constituent Dialogs of this view}

    nonDialogExtent:    LRect;      {intinsic overall extent, dialog + non-dialog actually}

    currentDialogImage: TDialogImage; {which descendent owns the mouse during drag}

    defaultButton:      TButton;    {which if any button is the default}
    hitButton:          TButton;    {which Button was last chosen}
    isShowing:          BOOLEAN;    {used to suppress meaningless screen actions for not-yet-showing box}

    paintFreeBoxes:     BOOLEAN;    {whether free-checkboxes are to be painted in one sense only}
    paintSense:         BOOLEAN;    { ... and if so, in which sense }
    startedPainting:    BOOLEAN;    {whether we've begun to paint and hence established paintSense}

    styleSheet:         TStyleSheet; {for use by text images seen in the view}

    mouseIsDown:        BOOLEAN;
    magnetCursor:       TCursorNumber; {to force CursorAt to return this value until mouseIsDown is FALSE}

{ *** Public Interface *** }
  {Creation/Destruction}
    FUNCTION  TDialogView.CREATE(object: TObject; heap: THeap;  itsExtentLRect: LRect; itsPanel: TPanel;
           itsPrintManager: TPrintManager; itsRes: Point): TDialogView;
    PROCEDURE TDialogView.Free; OVERRIDE;

  {Installing, Removing, Activating, Deactivating dialogs}
    PROCEDURE TDialogView.AddDialog(dialog: TDialog);
    FUNCTION  TDialogView.AddNewDialog(itsKey: S4): TDialog;
    PROCEDURE TDialogView.ActivateDialog(dialog: TDialog; whichWay: BOOLEAN);
    PROCEDURE TDialogView.RemoveDialog(dialog: TDialog; andFree: BOOLEAN);
    PROCEDURE TDialogView.ReplaceDialog(oldDialog, newDialog: TDialog);

  {Methods which client should redefine to get a dialogView also to have non-dialog behaviour}
    FUNCTION  TDialogView.XCursorAt(mouseLPt: LPoint): TCursorNumber; DEFAULT;
    PROCEDURE TDialogView.XDraw; DEFAULT;
    PROCEDURE TDialogView.XMousePress(mouseLPt: LPoint); DEFAULT;
    PROCEDURE TDialogView.XMouseMove(mouseLPt: LPoint); DEFAULT;
    PROCEDURE TDialogView.XMouseRelease; DEFAULT;

 {Buttons and checkboxes}
    PROCEDURE TDialogView.AbandonThatButton;
    PROCEDURE TDialogView.ButtonPushed(button: TButton);   {normally, TDialog's ButtonPushed is used}
    PROCEDURE TDialogView.CheckboxHit(checkbox: TCheckbox; toggleDirection: BOOLEAN);
    PROCEDURE TDialogView.PushButton(button: TButton);     {client or ToolKit may call}
    PROCEDURE TDialogView.SetDefaultButton(button: TButton);
     {NB:  PushButton sets the dialogView's hitButton to the requested button, assures that it
            is highlighted, and then calls the client's ButtonPushed method of the TDialog which
            is the parent of the button}

{ *** Private Interface ***  (Methods not expected to be redefined or called by client)}
    FUNCTION  TDialogView.CursorAt(mouseLPt: LPoint): TCursorNumber; OVERRIDE;
    PROCEDURE TDialogView.Draw; OVERRIDE;
    PROCEDURE TDialogView.EachActualPart(PROCEDURE DoToObject(filteredObj: TObject)); OVERRIDE;
    PROCEDURE TDialogView.MouseMove(mouseLPt: LPoint); OVERRIDE;
    PROCEDURE TDialogView.MousePress(mouseLPt: LPoint); OVERRIDE;
    PROCEDURE TDialogView.MouseRelease; OVERRIDE;
    PROCEDURE TDialogView.RecalcExtent; OVERRIDE;

END;  {TDialogView interface}

{-------------------------------------------------------------------------------------------------------}


TDialogImage = SUBCLASS OF TImage

    parent:         TDialogImage;
    isActive:       BOOLEAN;
    isEditable:     BOOLEAN;
    withID:         BOOLEAN;

{Creation/destruction}
    FUNCTION  TDialogImage.CREATE(object: TObject; heap: THeap; itsExtent: LRect; itsId: S255;
                itsView: TView; withChildren: BOOLEAN): TDialogImage;

    PROCEDURE TDialogImage.ControlHit(control: TDialogImage; toggleDirection: BOOLEAN); DEFAULT;
    FUNCTION  TDialogImage.DownAt(mouseLPt: LPoint):  TDialogImage; DEFAULT;
    PROCEDURE TDialogImage.Draw; OVERRIDE;
    PROCEDURE TDialogImage.DrawJustMe; {called by Draw after children, if any, are told to draw} DEFAULT;
    FUNCTION  TDialogImage.LaunchLayoutBox(view: TView): TImage; OVERRIDE;
    PROCEDURE TDialogImage.PrepareToAppear;
    PROCEDURE TDialogImage.RecalcExtent;  OVERRIDE;
    FUNCTION  TDialogImage.StillMyMouse(mouseLPt: LPoint): BOOLEAN; DEFAULT;

   {The following methods are stubs, redefined in TImageWithID}
    PROCEDURE TDialogImage.AddImage(dialogImage: TDialogImage); DEFAULT;
    PROCEDURE TDialogImage.ActivateImage(dialogImage: TDialogImage; whichWay: BOOLEAN); DEFAULT;
    PROCEDURE TDialogImage.BringToFront(dialogImage: TDialogImage); DEFAULT;
    PROCEDURE TDialogImage.ComeForward; DEFAULT;
    PROCEDURE TDialogImage.DeleteImage(dialogImage: TDialogImage; andFree: BOOLEAN); DEFAULT;
    PROCEDURE TDialogImage.EachActualPart(PROCEDURE DoToObject(filteredObj: TObject)); OVERRIDE;
    FUNCTION  TDialogImage.HasId(id: S255): BOOLEAN; DEFAULT;
    FUNCTION  TDialogImage.ObjectWithIDNumber(idNumber: INTEGER):  TDialogImage; DEFAULT;
    FUNCTION  TDialogImage.ObjWithId(id: S255): TDialogImage; DEFAULT;
    PROCEDURE TDialogImage.ReplaceImage(replacee, newValue: TDialogImage); DEFAULT;

    END;


TImageWithID = SUBCLASS OF TDialogImage   {same interface as TDialogImage, basically}

    children:   TList;  {of TDialogImage}
    id:         TId;
    idNumber:   INTEGER;

    FUNCTION  TImageWithID.CREATE(object: TObject; heap: THeap; itsExtent: LRect; itsId: S255;
                itsView: TView; withChildren: BOOLEAN): TImageWithID;
    FUNCTION  TImageWithID.Clone(heap: THeap): TObject;   OVERRIDE;
    PROCEDURE TImageWithID.Free; OVERRIDE;

    PROCEDURE TImageWithID.AddImage(dialogImage: TDialogImage); OVERRIDE;
    PROCEDURE TImageWithID.ActivateImage(dialogImage: TDialogImage; whichWay: BOOLEAN); OVERRIDE;
    PROCEDURE TImageWithID.BringToFront(dialogImage: TDialogImage); OVERRIDE;
    FUNCTION  TImageWithID.CursorAt(mouseLPt: LPoint): TCursorNumber; OVERRIDE;
    PROCEDURE TImageWithID.DeleteImage(dialogImage: TDialogImage; andFree: BOOLEAN); OVERRIDE;
    PROCEDURE TImageWithID.Draw; OVERRIDE;
    PROCEDURE TImageWithID.EachActualPart(PROCEDURE DoToObject(filteredObj: TObject)); OVERRIDE;
    PROCEDURE TImageWithID.EachVirtualPart(PROCEDURE DoToObject(filteredObj: TObject)); OVERRIDE;
    FUNCTION  TImageWithID.HasId(id: S255): BOOLEAN; OVERRIDE;
    PROCEDURE TImageWithID.HaveView(view: TView); OVERRIDE;
    FUNCTION  TImageWithID.LaunchLayoutBox(view: TView): TImage; OVERRIDE;
    FUNCTION  TImageWithID.ObjectWithIDNumber(idNumber: INTEGER):  TDialogImage; OVERRIDE;
    FUNCTION  TImageWithID.ObjWithId(id: S255):  TDialogImage; OVERRIDE;
    PROCEDURE TImageWithID.OffSetBy(deltaLPt: LPoint); OVERRIDE;
    PROCEDURE TImageWithID.RecalcExtent;   OVERRIDE;
    PROCEDURE TImageWithID.ReplaceImage(replacee, newValue: TDialogImage); OVERRIDE;
    FUNCTION  TImageWithID.StillMyMouse(mouseLPt : LPoint): BOOLEAN; OVERRIDE;

    END;

{-------------------------------------------------------------------------------------------------------}


TDialog = SUBCLASS OF TImageWithID

    stringKey:  TStringKey;   {essentially a unique 4-character ID by which this dialog is known}

{Creation}

    FUNCTION  TDialog.CREATE(object: TObject; heap: THeap; itsKey: S4; itsView: TView): TDialog;

{Creation of the basic dialog elements:}

  {Elements originating from phrase file; in each case, the text for the legend associated with the
        component, if any, as well as a LOCATION for the component, are obtained from the same entry
        in the phrase file, with the syntax

            <text>@<h-coordinate>,<v-coordinate>

         EXAMPLE:  Suppose the following 2 lines are in the Phrase File:

                449
                Next@430,50

        If we call NewButton(449, ...), then a button is created, with the text 'Next' inside it;
        the button is given idNumber 449, and is located at (430, 50)}

{***************************** PUBLIC INTERFACE -- USE THESE METHODS ************************************}

    FUNCTION  TDialog.NewButton(itsPhrase: INTEGER; itsMetrics: TButtonMetrics; sameSizedButton: TButton;
                    itsCmdNumber: TCmdNumber): TButton;

    FUNCTION  TDialog.NewCluster(itsPhrase: INTEGER): TCluster;

    FUNCTION  TDialog.NewFreeCheckbox(itsPhrase: INTEGER;  boxWidth: INTEGER;
        boxHeight: INTEGER; wantLabel: BOOLEAN; labelOffset: Point; itsTypeStyle: TTypeStyle): TCheckBox;

    FUNCTION  TDialog.NewInputFrame(itsPhrase: INTEGER; promptTypeStyle: TTypeStyle;
            inputOffset: Point; inputTypeStyle: TTypeStyle;
            maxInputChars: INTEGER; itsBorders: Rect; drawInputLRect: BOOLEAN;
            drawHitLRect: BOOLEAN): TInputFrame;

    FUNCTION  TDialog.NewLegend(itsPhrase: INTEGER; itsTypeStyle: TTypeStyle): TLegend;

    FUNCTION  TDialog.NewRowOfBoxes(itsPhrase: INTEGER; numberOfBoxes: INTEGER;
        startingIDNumber: INTEGER; boxWidth: INTEGER; boxHeight: INTEGER; boxSpacing: INTEGER): TCluster;

  {controls}
    PROCEDURE TDialog.ButtonPushed(button: TButton); DEFAULT; {client overrides often}
    PROCEDURE TDialog.CheckboxHit(checkbox: TCheckbox; toggleDirection: BOOLEAN); DEFAULT; {client overrides sometimes}
    PROCEDURE TDialog.ControlHit(control: TDialogImage; toggleDirection: BOOLEAN); OVERRIDE;
    PROCEDURE TDialog.PushButton(button: TButton);     {client or ToolKit may call}
    PROCEDURE TDialog.SelectInputFrame(inputFrame: TInputFrame);
    PROCEDURE TDialog.SetDefaultButton(button: TButton);


{************************************** PRIVATE INTERFACE **********************************************}

{These methods of TDialog are largely either for internal use of the building block, or maintained for
 backward compatability with earlier versions of the dialog building block}

  {"Standard" elements:}
    FUNCTION  TDialog.AddStdButton(itsId: S255; itsXLoc, itsYLoc: LONGINT; sameSizedButton: TButton;
                                            itsCmdNumber: TCmdNumber): TButton;
    PROCEDURE TDialog.AddOKButton(cmdNumber: TCmdNumber);      {OK Button}
    PROCEDURE TDialog.AddCancelButton(cmdNumber: TCmdNumber);  {Cancel Button}
    FUNCTION  TDialog.AddStdCluster(itsId: S255; itsXLoc, itsYLoc: LONGINT): TCluster;
    FUNCTION  TDialog.AddStdFreeCheckbox(itsId: S255; itsXLoc, itsYLoc: LONGINT): TCheckBox;
    FUNCTION  TDialog.AddStdInputFrame(itsId: S255; itsXLoc: LONGINT;
                                            itsYLoc: LONGINT; maxInputChars : INTEGER): TInputFrame;
    FUNCTION  TDialog.AddStdLegend(itsId: S255; itsXLoc, itsYLoc: LONGINT;
                                            itsTypeStyle: TTypeStyle): TLegend;
    FUNCTION  TDialog.AddSysLegend(itsId: S255; itsXLoc, itsYLoc: LONGINT): TLegend;

  {General creation of dialogImages}
    FUNCTION  TDialog.AddButton(itsId: S255; itsLocation: LPoint; itsMetrics: TButtonMetrics;
                                            sameSizedButton: TButton; itsCmdNumber: TCmdNumber): TButton;

    FUNCTION  TDialog.AddFreeCheckbox(itsID: S255; itsXLoc, itsYLoc: LONGINT; boxWidth: INTEGER;
        boxHeight: INTEGER; wantLabel: BOOLEAN; labelOffset: Point; itsTypeStyle: TTypeStyle): TCheckbox;

    FUNCTION  TDialog.AddBigFreeCheckbox(itsId: S255; itsXLoc, itsYLoc: LONGINT): TCheckbox;

    FUNCTION  TDialog.AddRowOfBoxes(itsID: S255; itsXLoc, itsYLoc: LONGINT; numberOfBoxes: INTEGER;
        startingIDNumber: INTEGER; boxWidth: INTEGER; boxHeight: INTEGER; boxSpacing: INTEGER): TCluster;

    FUNCTION  TDialog.AddInputFrame(itsId: S255;
            promptLocation: LPoint; promptTypeStyle: TTypeStyle;
            inputLocation:  LPoint; inputTypeStyle: TTypeStyle;
            maxInputChars: INTEGER; itsBorders: Rect; drawInputLRect: BOOLEAN;
            drawHitLRect: BOOLEAN): TInputFrame;

    FUNCTION  TDialog.DownAt(mouseLPt: LPoint): TDialogImage; OVERRIDE;
    PROCEDURE TDialog.RecalcExtent; OVERRIDE;

    END;


{-------------------------------------------------------------------------------------------------------}


TButton = SUBCLASS OF TImageWithID

    cmdNumber:              TCmdNumber;
    minWidth:               INTEGER;
    isHighlighted:          BOOLEAN;
    nextSameSizedButton:    TButton;
    legend:                 TLegend;
    buttonMetrics:          TButtonMetrics;

{Creation/Destruction}
    FUNCTION  TButton.CREATE(object: TObject; heap: THeap; itsId: S255; itsView: TView;
         itsLocation: LPoint; itsMetrics: TButtonMetrics;  sameSizedButton: TButton;
         itsCmdNumber: TCmdNumber):  TButton;

    PROCEDURE TButton.DrawJustMe; OVERRIDE;
    PROCEDURE TButton.Highlight(highTransit: THighTransit);
    FUNCTION  TButton.LaunchLayoutBox(view: TView): TImage; OVERRIDE;
    PROCEDURE TButton.MousePress(mouseLPt: LPoint); OVERRIDE;
    PROCEDURE TButton.MouseRelease; OVERRIDE;
    PROCEDURE TButton.RecalcExtent; OVERRIDE;
    PROCEDURE TButton.Recompute(minWidth: INTEGER);
    FUNCTION  TButton.StillMyMouse(mouseLPt: LPoint): BOOLEAN; OVERRIDE;

END; {TButton interface}

{-------------------------------------------------------------------------------------------------------}

TCheckbox = SUBCLASS of TImageWithID

    isSelected:   BOOLEAN;

    rectImage:    TRectImage;     {also a child}
    legend:       TLegend;        {if nonnil, also a child}

    FUNCTION TCheckbox.CREATE(object: TObject; heap: THeap; itsId: S255; itsView: TView;
        itsLocation: LPoint; boxWidth: INTEGER; boxHeight: INTEGER; wantLabel: BOOLEAN;
        labelOffset: Point; itsTypeStyle: TTypeStyle): TCheckbox;

    PROCEDURE TCheckbox.ChangeLabel(newS255: S255);
    FUNCTION  TCheckbox.CursorAt(mouseLPt: LPoint): TCursorNumber; OVERRIDE;
    PROCEDURE TCheckbox.Draw; OVERRIDE;
    FUNCTION  TCheckbox.LaunchLayoutBox(view: TView): TImage; OVERRIDE;
    PROCEDURE TCheckbox.MousePress(mouseLPt: LPoint); OVERRIDE;
    PROCEDURE TCheckbox.Toggle;

  END;  {TCheckbox interface}

{-------------------------------------------------------------------------------------------------------}

TCluster = SUBCLASS of TImageWithID

   {children:   TList;  (of TCheckbox) }

    location:   LPoint;                {only used for adding the first aligned checkbox}
    hitBox:     TCheckbox;             {which one was just successfully queried by Hit}
    hiLitBox:   TCheckbox;             {which one is highlighted}
    lastBox:    TCheckBox;             {the checkbox most recently added checkbox}

    FUNCTION  TCluster.CREATE(object: TObject; heap: THeap; itsId: S255; itsView: TView;
                                itsLocation : LPoint): TCluster;

{****** PUBLIC INTERFACE:
 ******
 ****** Create a cluster using TDialog.NewCluster; add checkboxes to it by calling any of the following
 ****** three methods.  To change which box is selected in the cluster programmatically, call SelectBox
 ******
 ****** To find out which box is selected in a cluster, look at cluster.hiLitBox.idNumber}

     FUNCTION  TCluster.NewAlignedCheckbox(itsPhrase: INTEGER; selectThisOne: BOOLEAN): TCheckbox;
     FUNCTION  TCluster.NewCheckbox(itsPhrase: INTEGER; boxWidth: INTEGER;
                       boxHeight: INTEGER; wantLabel: BOOLEAN; labelOffset: Point; itsTypeStyle: TTypeStyle;
                       selectThisOne: BOOLEAN): TCheckbox;
     PROCEDURE TCluster.AddRowOfBoxes(numberOfBoxes: INTEGER; startingIDNumber: INTEGER;
                                boxWidth: INTEGER; boxHeight: INTEGER; boxSpacing: INTEGER);

    PROCEDURE TCluster.SelectBox(checkbox: TCheckbox); {select this box, deselecting others}

{****** PRIVATE INTERFACE:
 ******
 ******  These remaining methods of TCluster are for primarily for internal use:}

    FUNCTION  TCluster.AddAlignedCheckbox(itsId: S255; selectThisOne: BOOLEAN): TCheckbox;
    FUNCTION  TCluster.AddCheckbox(itsID: S255; itsLocation: LPoint; boxWidth: INTEGER;
                       boxHeight: INTEGER; wantLabel: BOOLEAN; labelOffset: Point; itsTypeStyle: TTypeStyle;
                       selectThisOne: BOOLEAN): TCheckbox;
    FUNCTION  TCluster.Hit(mouseLPt: LPoint): BOOLEAN; OVERRIDE;
    PROCEDURE TCluster.MousePress(mouseLPt: LPoint); OVERRIDE;
    FUNCTION  TCluster.StillMyMouse(mouseLPt: LPoint): BOOLEAN; OVERRIDE;

END; {TCluster interface}

{-------------------------------------------------------------------------------------------------------}


TInputFrame = SUBCLASS OF TImageWithID

    textDialogImage:   TTextDialogImage;
    prompt:            TLegend;

    borders:           Rect;

    drawInputLRect:    BOOLEAN;  {whether or not to draw a faint box around the input LRect}
    drawHitLRect:      BOOLEAN;  {whether or not to frame the hit rectangle}
    maxInputChars:     INTEGER;
    inputTypeStyle:    TTypeStyle;

    FUNCTION  TInputFrame.CREATE(object: TObject; heap: THeap; itsId: S255; itsView: TView;
           promptLocation: LPoint; promptTypeStyle: TTypeStyle;
           inputLocation:  LPoint; inputTypeStyle: TTypeStyle;  maxInputChars: INTEGER;
           itsBorders: Rect; drawInputLRect: BOOLEAN; drawHitLRect: BOOLEAN
           ): TInputFrame;


{ *********************************************** PUBLIC INTERFACE **************************************** }

   {Create an input frame by calling TDialog.NewInputFrame; use GetContents and SupplantContents
    to find out what has been typed, and to change what appears in the typing area}

    PROCEDURE TInputFrame.GetContents(VAR theStr: S255);     {inspect current frame contents}
    PROCEDURE TInputFrame.SupplantContents(newStr: S255);    {change current frame contents}

{ ********************************************** PRIVATE INTERFACE **************************************** }

    FUNCTION  TInputFrame.CursorAt(mouseLPt: LPoint): TCursorNumber; OVERRIDE;
    PROCEDURE TInputFrame.Draw; OVERRIDE;
    FUNCTION  TInputFrame.LaunchLayoutBox(view: TView): TImage; OVERRIDE;
    PROCEDURE TInputFrame.MousePress(mouseLPt: LPoint); OVERRIDE;
    PROCEDURE TInputFrame.RecalcExtent; OVERRIDE;
    FUNCTION  TInputFrame.StillMyMouse(mouseLPt: LPoint): BOOLEAN; OVERRIDE;

 END;   {TInputFrame interface}

{-------------------------------------------------------------------------------------------------------}

TLegend = SUBCLASS OF TDialogImage

        location:           LPoint;
        paragraph:          TParagraph;
        wouldBeDraggable:   BOOLEAN;        {whether, during layout, it should itself be draggable}
        usesSysFont:        BOOLEAN;        {whether it is in system font -- a special case}

    FUNCTION  TLegend.CREATE(object: TObject; heap: THeap; itsChars: S255; itsView: TView;
        itsLocation: LPoint; itsTypeStyle: TTypeStyle): TLegend;
    PROCEDURE TLegend.Free; OVERRIDE;

{ *********************************************** PUBLIC INTERFACE **************************************** }

    PROCEDURE TLegend.ChangeToPhrase(newPhrase: INTEGER); {for getting new text from phrase file}
    PROCEDURE TLegend.ChangeString(newString: S255);      {for getting new text from a string}
    PROCEDURE TLegend.GetString(VAR itsString: S255); {determine current chars residing in the legend}

{ ********************************************** PRIVATE INTERFACE **************************************** }
    PROCEDURE TLegend.Draw; OVERRIDE;
    PROCEDURE TLegend.GetBoxRight;   {sets extent based on current chars & location}
    FUNCTION  TLegend.LaunchLayoutBox(view: TView): TImage; OVERRIDE;
    PROCEDURE TLegend.OffsetBy(deltaLPt: LPoint); OVERRIDE;
    PROCEDURE TLegend.RecalcExtent; OVERRIDE;

    END;

{ ------------------------------- classes implemented in file UDialog3 -------------------------------}



TPicObject = SUBCLASS OF TImageWithID {An Object which holds a QD Picture File} {CAUTION: totally untested}

    picture:        PicHandle;
    boxAtCreation:  Rect;   {need to get itsView parameter into all these guys}

    FUNCTION  TPicObject.CREATE(object: TObject; heap: THeap; itsId: S255;
         itsView: TView; itsLocation: LPoint; itsPicHandle: PicHandle): TPicObject;
    PROCEDURE TPicObject.Free; OVERRIDE;

    PROCEDURE TPicObject.Draw; OVERRIDE;

    END;

{-------------------------------------------------------------------------------------------------------}

  TRectImage = SUBCLASS OF TDialogImage   {a rectangle packaged as a object}

        penState: PenState;

    FUNCTION TRectImage.CREATE(object: TObject; heap: THeap; itsExtent: LRect; itsId: S255;
        itsView: TView; itsPenState: PenState; withChildren: BOOLEAN): TRectImage;

    PROCEDURE TRectImage.Draw; OVERRIDE;
    FUNCTION  TRectImage.LaunchLayoutBox(view: TView): TImage; OVERRIDE;
    END;

{-------------------------------------------------------------------------------------------------------}


TTextDialogImage = SUBCLASS OF TImageWithID

     textImage:         TTextImage;
     wouldBeDraggable:  BOOLEAN;
     refCount:          INTEGER;

    FUNCTION  TTextDialogImage.CREATE(object: TObject; heap: THeap; itsExtent: LRect; itsId: S255;
                  itsView: TView; itsTypeStyle: TTypeStyle;
                  itsInitialChars: S255): TTextDialogImage;
    PROCEDURE TTextDialogImage.Free; OVERRIDE;

    PROCEDURE TTextDialogImage.ChangeRefCountBy(delta: INTEGER);
    FUNCTION  TTextDialogImage.CursorAt(mouseLPt: LPoint): TCursorNumber; OVERRIDE;
    PROCEDURE TTextDialogImage.Draw; OVERRIDE;
    FUNCTION  TTextDialogImage.LaunchLayoutBox(view: TView): TImage; OVERRIDE;
    PROCEDURE TTextDialogImage.MousePress(mouseLPt: LPoint); OVERRIDE;
    PROCEDURE TTextDialogImage.OffsetBy(deltaLPt: LPoint); OVERRIDE;
     END;

{-------------------------------------------------------------------------------------------------------}

TFrameSelection = SUBCLASS OF TSelection  {the phony selection covering TextSelection in an input frame}

    inputFrame: TInputFrame;  {the input frame in which the selection occurs}

    FUNCTION  TFrameSelection.CREATE(object: TObject; heap: THeap; itsInputFrame: TInputFrame): TFrameSelection;

    FUNCTION  TFrameSelection.CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN; OVERRIDE;
    PROCEDURE TFrameSelection.KeyChar(ch: CHAR); OVERRIDE;
    PROCEDURE TFrameSelection.KeyEnter(dh, dv: INTEGER); OVERRIDE;
    PROCEDURE TFrameSelection.KeyReturn; OVERRIDE;
    PROCEDURE TFrameSelection.KeyTab(fBackward: BOOLEAN);  OVERRIDE;
    PROCEDURE TFrameSelection.MousePress(mouseLPt: LPoint);  OVERRIDE;
    PROCEDURE TFrameSelection.PerformCommand(command: TCommand; cmdPhase: TCmdPhase); OVERRIDE;
    PROCEDURE TFrameSelection.Restore; OVERRIDE;

END;  {TFrameSelection interface}


TPlannerView = SUBCLASS OF TDialogView  {a view within which images are laid out}

  {Variables}

    viewBeingPlanned:   TView;

    allowSketching:     BOOLEAN;   {for internal use of the layout mechanism}
    retainPickedBox:    BOOLEAN;
    currentLayoutBox:   TLayoutBox;

  {Creation/Destruction}
    FUNCTION  TPlannerView.CREATE(object: TObject; heap: THeap; itsViewBeingPlanned: TView;
               itsPanel: TPanel; itsAllowSketching: BOOLEAN; itsRetainPickedBox: BOOLEAN): TPlannerView;
    PROCEDURE TPlannerView.Init(itsListOfImages: TList);
    FUNCTION  TPlannerView.NewLayoutBox(image: TImage): TLayoutBox; {return NIL if element not to be shown}

    PROCEDURE TPlannerView.Free; OVERRIDE;

  {Display}
    PROCEDURE TPlannerView.Draw; OVERRIDE;

  {Mouse Tracking}
    FUNCTION  TPlannerView.CursorAt(mouseLPt: LPoint): TCursorNumber; OVERRIDE;
    PROCEDURE TPlannerView.MouseMove(mouseLPt: LPoint); OVERRIDE;
    PROCEDURE TPlannerView.MousePress(mouseLPt: LPoint); OVERRIDE;
    PROCEDURE TPlannerView.MouseRelease; OVERRIDE;

  {Enumeration of components}
    PROCEDURE TPlannerView.EachActualPart(PROCEDURE DoToObject(filteredObj: TObject)); OVERRIDE;

    END;

{-------------------------------------------------------------------------------------------------------}


    TLayoutBox = SUBCLASS OF TImageWithID

        {Variables}
        manipulee:                  TImage;
        titleTab:                   TTitleTab;

        suppressDrawingManipulee:   BOOLEAN;

        isResizable:                BOOLEAN;
        borders:                    Rect;
        wouldMakeSelection:         BOOLEAN;   {client must directly set if not wanting default 'FALSE'}

        isDraggable:                BOOLEAN;
        shouldFrame:                BOOLEAN;

        hasDraggee:                 BOOLEAN;

      {Creation/Destruction}
        FUNCTION  TLayoutBox.CREATE(object: TObject; heap: THeap; baseExtent: LRect; itsID: S255;
            itsParent: TLayoutBox; itsView: TView; itsManipulee: TImage; itsBorders: Rect;
            itsResizable: BOOLEAN; itsSuppression: BOOLEAN; withChildren: BOOLEAN): TLayoutBox;
        PROCEDURE TLayoutBox.Free; OVERRIDE;

      {Change and Display}
        PROCEDURE TLayoutBox.ChangeDragState(enteringDrag: BOOLEAN);
        PROCEDURE TLayoutBox.ConsiderMouse(mouseLPt: LPoint; VAR madeSelection: BOOLEAN;
                                            VAR pickedLayoutBox: TLayoutBox); DEFAULT;
        FUNCTION  TLayoutBox.CursorAt(mouseLPt: LPoint): TCursorNumber; OVERRIDE;
        PROCEDURE TLayoutBox.Draw; OVERRIDE;
        PROCEDURE TLayoutBox.DrawJustMe; OVERRIDE;
        PROCEDURE TLayoutBox.FreeManipulee;
        PROCEDURE TLayoutBox.Highlight(highTransit: THighTransit);
        PROCEDURE TLayoutBox.MousePress(mouseLPT: LPoint); OVERRIDE;
        PROCEDURE TLayoutBox.Move(deltaLPt: LPoint); DEFAULT;
        FUNCTION  TLayoutBox.NoTitleTab(heap: THeap): TTitleTab;
        PROCEDURE TLayoutBox.OffsetBy(deltaLPt: LPoint); OVERRIDE;
        PROCEDURE TLayoutBox.OffsetLayoutBoxBy(deltaLPt: LPoint; textImageAsWell: BOOLEAN); DEFAULT;
        PROCEDURE TLayoutBox.RecalcExtent; OVERRIDE;
        PROCEDURE TLayoutBox.Resize(newExtent: LRect); OVERRIDE;
        PROCEDURE TLayoutBox.TabGrabbed; DEFAULT;

        END;

    TLegendLayoutBox = SUBCLASS OF TLayoutBox  {manipulee is a TLegend}

        textDialogImage:  TTextDialogImage;

      {Creation/Destruction}
        FUNCTION  TLegendLayoutBox.CREATE(object: TObject; heap: THeap; itsView: TView; itsLegend: TLegend
                ): TLegendLayoutBox;

        FUNCTION  TLegendLayoutBox.CursorAt(mouseLPt: LPoint): TCursorNumber; OVERRIDE;
        PROCEDURE TLegendLayoutBox.Draw; OVERRIDE;
        PROCEDURE TLegendLayoutBox.OffsetBy(deltaLPt: LPoint); OVERRIDE;
        PROCEDURE TLegendLayoutBox.OffsetLayoutBoxBy(deltaLPt: LPoint; textImageAsWell: BOOLEAN); OVERRIDE;
          {use of the second argument is strange and non self-explanatory; comments in the internal
           documentation may help.  Nobody should be calling this old boy from outside, anyway}
        PROCEDURE TLegendLayoutBox.MousePress(mouseLPT: LPoint); OVERRIDE;
        PROCEDURE TLegendLayoutBox.RecalcExtent; OVERRIDE;

        END;


    TButtonLayoutBox = SUBCLASS OF TLayoutBox  {manipulee is a TButton}

      {Variables}
        nextSameSizedBox:   TButtonLayoutBox;
        oldLegendTopLeft:   LPoint;

      {Creation/Destruction}
        FUNCTION  TButtonLayoutBox.CREATE(object: TObject; heap: THeap; itsButton: TButton;
                                            itsView: TView): TButtonLayoutBox;

      {Other Methods}
        PROCEDURE TButtonLayoutBox.ConsiderMouse(mouseLPt: LPoint; VAR madeSelection: BOOLEAN;
                                        VAR pickedLayoutBox: TLayoutBox); OVERRIDE;
        FUNCTION  TButtonLayoutBox.CursorAt(mouseLPt: LPoint): TCursorNumber; OVERRIDE;
        PROCEDURE TButtonLayoutBox.DrawJustMe; OVERRIDE;
        PROCEDURE TButtonLayoutBox.OffsetBy(deltaLPt: LPoint); OVERRIDE;
        PROCEDURE TButtonLayoutBox.RecalcExtent; OVERRIDE;
        PROCEDURE TButtonLayoutBox.RecalcJustMe;

        END;


    TTitleTab = SUBCLASS OF TImage

        layoutBox:          TLayoutBox;
        legend:             TLegend;
        shouldDrawLegend:   BOOLEAN;  {FALSE if string is too wide to fit}

        FUNCTION  TTitleTab.CREATE(object: TObject; heap: THeap; itsLayoutBox: TLayoutBox; itsHeight: INTEGER;
            itsCaption: S255): TTitleTab;
        PROCEDURE TTitleTab.Free; OVERRIDE;

        PROCEDURE TTitleTab.Draw; OVERRIDE;
        PROCEDURE TTitleTab.OffsetBy(deltaLPt: LPoint); OVERRIDE;
        PROCEDURE TTitleTab.Resize(newExtent: LRect); OVERRIDE;
        END;


    TLayPickSelection = SUBCLASS OF TSelection

      {Variables}
        layoutBox:  TLayoutBox;

        FUNCTION  TLayPickSelection.CREATE(object: TObject; heap: THeap; itsView: TPlannerView; itsKind: INTEGER;
                         itsLayoutBox: TLayoutBox; itsAnchorLPt: LPoint): TLayPickSelection;

        FUNCTION  TLayPickSelection.CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN; OVERRIDE;
        PROCEDURE TLayPickSelection.Deselect; OVERRIDE;
        PROCEDURE TLayPickSelection.Highlight(highTransit: THighTransit); OVERRIDE;
        PROCEDURE TLayPickSelection.KeyClear; OVERRIDE;
        PROCEDURE TLayPickSelection.MouseMove(mouseLPt: LPoint); OVERRIDE;
        PROCEDURE TLayPickSelection.MouseRelease; OVERRIDE;
        PROCEDURE TLayPickSelection.Restore; OVERRIDE;

        END;


    TLayMoveCmd = SUBCLASS OF TCommand

      {Variables}
        layoutBox:  TLayoutBox;

        hOffset:    LONGINT;
        vOffset:    LONGINT;

      {Creation}
        FUNCTION  TLayMoveCmd.CREATE(object: TObject; heap: THeap; itsLayoutBox: TLayoutBox;
                                    itsHOffset, itsVOffset: LONGINT): TLayMoveCmd;

      {Command Execution}
        PROCEDURE  TLayMoveCmd.Perform(cmdPhase: TCmdPhase); OVERRIDE;

        END;

    TEditLegendSelection = SUBCLASS OF TSelection

      {Variables}
       legendLayoutBox: TLegendLayoutBox;
       hostLegend:      TLegend;
       textDialogImage: TTextDialogImage;
       suppressHost:    BOOLEAN;
       tripleClick:     BOOLEAN; {+SW+}

      {Creation/Destruction}
       FUNCTION  TEditLegendSelection.CREATE(object: TObject; heap: THeap; itsLegendLayoutBox: TLegendLayoutBox;
                                       itsAnchorLPt: LPoint): TEditLegendSelection;
       FUNCTION  TEditLegendSelection.Clone(heap: THeap): TObject;  OVERRIDE;
       PROCEDURE TEditLegendSelection.Deselect; OVERRIDE;
       PROCEDURE TEditLegendSelection.Free; OVERRIDE;

      {Udders}
       FUNCTION  TEditLegendSelection.CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN; OVERRIDE;
       PROCEDURE TEditLegendSelection.KeyBack(fWord: BOOLEAN); OVERRIDE;
       PROCEDURE TEditLegendSelection.KeyChar(ch: CHAR); OVERRIDE;
       PROCEDURE TEditLegendSelection.KeyEnter(dh, dv: INTEGER); OVERRIDE;
       PROCEDURE TEditLegendSelection.KeyReturn; OVERRIDE;
       PROCEDURE TEditLegendSelection.MouseMove(mouseLPt: LPoint); OVERRIDE; {+SW+}
       PROCEDURE TEditLegendSelection.MousePress(mouseLPt: LPoint); OVERRIDE; {+SW+}
       PROCEDURE TEditLegendSelection.MouseRelease; OVERRIDE; {+SW+}
       FUNCTION  TEditLegendSelection.NewCommand(cmdNumber: TCmdNumber): TCommand; OVERRIDE;
       PROCEDURE TEditLegendSelection.PerformCommand(command: TCommand; cmdPhase: TCmdPhase);  OVERRIDE;
       PROCEDURE TEditLegendSelection.Restore; OVERRIDE;
       PROCEDURE TEditLegendSelection.Reveal(asMuchAsPossible: BOOLEAN);  OVERRIDE;

       END;


    TDialogDesignWindow = SUBCLASS OF TDialogWindow

        hostWindow:         TWindow;
        hostDialogView:     TDialogView;
        fromDialogBox:      BOOLEAN;

     FUNCTION  TDialogDesignWindow.CREATE(object: TObject; heap: THeap;
                    itsHostDialogView: TDialogView): TDialogDesignWindow;

     FUNCTION  TDialogDesignWindow.CanDoCommand(cmdNumber: TCmdNumber; VAR checkIt: BOOLEAN): BOOLEAN; OVERRIDE;
     FUNCTION  TDialogDesignWindow.NewCommand(cmdNumber: TCmdNumber): TCommand; OVERRIDE;
     PROCEDURE TDialogDesignWindow.RelinquishControl;
     PROCEDURE TDialogDesignWindow.Resize(moving: BOOLEAN); OVERRIDE;
     PROCEDURE TDialogDesignWindow.SeizeControl;

     END;



{ ------------------------------- classes implemented in file UDialog4 -------------------------------}


TStdPrintManager = SUBCLASS OF TPrintManager

    FUNCTION  TStdPrintManager.CREATE(object: TObject; heap: THeap): TStdPrintManager;

    PROCEDURE TStdPrintManager.EnterPageEditting; OVERRIDE;
    PROCEDURE TStdPrintManager.Init(itsMainView: TView; itsDfltMargins: LRect); OVERRIDE;
    PROCEDURE TStdPrintManager.ReactToPrinterChange; OVERRIDE;
    PROCEDURE TStdPrintManager.SetDfltHeadings;  OVERRIDE;

    END;

TLegendHeading = SUBCLASS OF THeading

    masterLegend:   TLegend;
    currentLegend:  TLegend;

    topToBaseline:  INTEGER;  {offset from box top to baseline}
    borders:        Rect;    {size by which box exceeds legend's extent}

  {Creation/Destruction}
    FUNCTION  TLegendHeading.CREATE(object: TObject; heap: THeap; itsPrintManager: TPrintManager;
        itsString: S255; itsTypeStyle: TTypeStyle;
        itsPageAlignment: TPageAlignment; itsOffsetFromAlignment: LPoint;
        itsBorders: Rect): TLegendHeading;
    PROCEDURE  TLegendHeading.Free; OVERRIDE;

  {Nyingine}
    PROCEDURE TLegendHeading.AdjustForPage(pageNumber: LONGINT; editing: BOOLEAN); OVERRIDE;
    PROCEDURE TLegendHeading.Draw; OVERRIDE;
    FUNCTION  TLegendHeading.LaunchLayoutBox(view: TView): TImage; OVERRIDE;
    PROCEDURE TLegendHeading.OffsetBy(deltaLPt: LPoint); OVERRIDE;
    PROCEDURE TLegendHeading.RecalcExtent; OVERRIDE;
    FUNCTION  TLegendHeading.ShouldFrame: BOOLEAN; OVERRIDE;

    END;


TPageDesignWindow = SUBCLASS OF TDialogWindow

    hostView:       TView;  {the view whose pages are being designed in this dialog}
    layoutPanel:    TPanel; {my controlPanel is the status panel}

    FUNCTION  TPageDesignWindow.CREATE(object: TObject; heap: THeap; itsHostView: TView): TPageDesignWindow;

    PROCEDURE TPageDesignWindow.Disappear;  OVERRIDE;
    FUNCTION  TPageDesignWindow.NewCommand(cmdNumber: TCmdNumber): TCommand;  OVERRIDE;

    END;


TPagePlannerView = SUBCLASS OF TPlannerView

    FUNCTION TPagePlannerView.CREATE(object: TObject; heap: THeap; itsPrintManager: TPrintManager;
                    itsPanel: TPanel): TPagePlannerView;

    PROCEDURE TPagePlannerView.Draw; OVERRIDE;

    END;


TPageStatusDialog = SUBCLASS OF TDialog

    currentHeading:     THeading;

    oddEvenCluster:     TCluster;
    minPageFrame:       TInputFrame;
    maxPageFrame:       TInputFrame;
    alignCluster:       TCluster;
    unitsCluster:       TCluster;
    marginTitle:        TLegend;

    leftCluster:        TCluster;
    topCluster:         TCluster;
    rightCluster:       TCluster;
    bottomCluster:      TCluster;

  {Creation/Destruction}
    FUNCTION  TPageStatusDialog.CREATE(object: TObject; heap: THeap; itsPanel: TPanel): TPageStatusDialog;

  {Sonst}
    PROCEDURE TPageStatusDialog.ButtonPushed(button: TButton); OVERRIDE;
    PROCEDURE TPageStatusDialog.CheckboxHit(checkbox: TCheckbox; toggleDirection: BOOLEAN); OVERRIDE;
    FUNCTION  TPageStatusDialog.DownAt(mouseLPt: LPoint): TDialogImage; OVERRIDE;
    PROCEDURE TPageStatusDialog.Draw; OVERRIDE;
    PROCEDURE TPageStatusDialog.InspectHeadingParms(VAR oddOnly, evenOnly: BOOLEAN;
                                    VAR pageAlignment: TPageAlignment; VAR minPage, maxPage: LONGINT);
    PROCEDURE TPageStatusDialog.SetHeadingParms(oddOnly, evenOnly: BOOLEAN;
                                    pageAlignment: TPageAlignment;  minPage, maxPage: LONGINT);
    END;


TPageLayoutBox = SUBCLASS OF TLayoutBox


  {Creation/Destruction}
    FUNCTION  TPageLayoutBox.CREATE(object: TObject; heap: THeap; itsView: TView; itsHeading: THeading;
                    itsResizable: BOOLEAN): TPageLayoutBox;

    PROCEDURE TPageLayoutBox.FreeManipulee; OVERRIDE;
    PROCEDURE TPageLayoutBox.TabGrabbed; OVERRIDE;
    END;


TLgHdngLayoutBox = SUBCLASS OF TPageLayoutBox

    legendLayoutBox: TLegendLayoutBox;

    FUNCTION  TLgHdngLayoutBox.CREATE(object: TObject; heap: THeap; itsView: TView;
        itsLegendHeading: TLegendHeading): TLgHdngLayoutBox;

    FUNCTION  TLgHdngLayoutBox.CursorAt(mouseLPt: LPoint): TCursorNumber; OVERRIDE;
    PROCEDURE TLgHdngLayoutBox.Draw; OVERRIDE;
    PROCEDURE TLgHdngLayoutBox.MousePress(mouseLPT: LPoint); OVERRIDE;
    PROCEDURE TLgHdngLayoutBox.Move(deltaLPt: LPoint); OVERRIDE;
    PROCEDURE TLgHdngLayoutBox.RecalcExtent; OVERRIDE;

    END;


VAR
    stdFrameBorders:        Rect;           {extra space around an input-frame and its text}
    stdHdngBorders:         Rect;           {extra space around a standard heading}
    stdHdngTypeStyle:       TTypeStyle;     {tile 12 monospaced, normal faces, for titles}
    stdIDBorders:           Rect;           {a title tab with string, and a small border on the other 3 sides}
    stdInputTypeStyle:      TTypeStyle;     {std input font/faces}
    stdFrmeOffset:          Point;          {std distance between input frame's prompt and input rect}
    stdLabelOffset:         Point;          {offset from top-left corner of a checkbox to leftmost pt of baseline of label}
    stdPlainBorders:        Rect;           {a slim captionless title tab, and a small border on the other 3 sides}
    stdThinBorders:         Rect;           {a slim captionless title tab above; no other borders}
    titleTypeStyle:         TTypeStyle;     {tile 15 monospaced, for titles of layout boxes}
    {NB: All the above are initialized in the creation block of TDialogWindow}

    stdButtonMetrics:       TButtonMetrics; {reinitialized in TDialog.CREATE each time}


{Unit-Global Procedures}

FUNCTION  NewStdDialogWindow(heap: THeap; itsHeight: INTEGER; itsKeyResponse, itsMenuResponse,
                itsDownInMainWindowResponse: TDiResponse): TDialogWindow;
            {sets up a standard, nonresizable, dialogWindow, and installs a single Panel into it, into
             which it installs a single DialogView}

FUNCTION  NewStdLegend(heap: THeap; itsChars: S255; itsXLoc, itsYLoc: LONGINT; itsView: TView;
                       itsTypeStyle: TTypeStyle): TLegend;

FUNCTION  NewSysLegend(heap: THeap; itsChars: S255; itsXLoc, itsYLoc: LONGINT; itsView: TView): TLegend;

PROCEDURE SetParaExtent(paragraph: TParagraph; view: TView; location: LPoint; VAR extentLRect: LRect);

PROCEDURE LRectAddBorders(baseLRect: LRect; borders: Rect; VAR resultLRect: LRect);

PROCEDURE GetTextAndLocation(phraseNumber: INTEGER; VAR itsChars: S255; VAR itsLocation: LPoint);


IMPLEMENTATION

{$I LIBTK/UDialog2}    {dialogs}
{$I LIBTK/UDialog3}    {layout}
{$I LIBTK/UDialog4}    {page margins}

(**********
{$I UDialog2}    {dialogs}
{$I UDialog3}    {layout}
{$I UDialog4}    {page margins}
**********)

END.  {unit UDialog}

ÿ